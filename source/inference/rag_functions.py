import faiss
import torch
from sentence_transformers import SentenceTransformer
import pickle
import re
import string


# Function to load the FAISS index
def load_faiss_index(index_file_path="../files/rag/faiss_index.bin"):
    faiss_index = faiss.read_index(index_file_path)
    return faiss_index


# Function to perform search on the FAISS index
def search_faiss_index(query_text, faiss_index, model=None, top_k=5):
    if model is None:
        model = SentenceTransformer('all-mpnet-base-v2', device="cpu")

    query_embedding = model.encode(query_text, convert_to_tensor=True)
    query_embedding = torch.nn.functional.normalize(query_embedding, p=2, dim=0).cpu().numpy().reshape(1, -1)

    distances, indices = faiss_index.search(query_embedding, top_k)
    return distances, indices


# Function to perform RAG (Retrieve and Generate) search
def search_rag(query_text, index_file_path="../../files/rag/faiss_index.bin",
               chunks_path="../../files/rag/tspec_chunks_markdown.pkl",
               top_k=5):
    faiss_index = load_faiss_index(index_file_path)
    tspec_chunks = load_chunks(chunks_path)
    distances, indices = search_faiss_index(query_text, faiss_index, top_k=top_k)

    result_texts = []
    for i, idx in enumerate(indices[0]):
        result_texts.append(f"Information {i + 1}:\n{tspec_chunks[idx]['text']}\n")

    del tspec_chunks
    del faiss_index
    return "\n".join(result_texts)


# Function to load chunks from a file
def load_chunks(filename):
    with open(filename, 'rb') as f:
        chunks = pickle.load(f)
    return chunks


def extract_option(text, first_option=True):
    """
    Extract the option part from the answer string, removing all punctuation and converting to lowercase.

    Parameters:
    - answer: A string containing the answer in the format 'option X: ...'.

    Returns:
    - String: Extracted option (e.g., 'option 2'), or None if no match is found.
    """
    if first_option:
        # Remove all punctuation and convert to lowercase
        cleaned_answer = re.sub(r'[^\w\s]', '', text.lower())
        # Find all matches for the format "option X"
        matches = re.findall(r'option \d+', cleaned_answer)
        # Return the last match with stripped whitespace if any found, otherwise None
        return matches[-1].strip() if matches else None
    else:
        # Find all occurrences of 'option X:' followed by text, where X can be any number
        option_matches = re.findall(r'option\s*\d+:\s*(.*)', text, re.IGNORECASE | re.DOTALL)

        # Return the text after the last 'option X:' found
        return option_matches[-1].strip() if option_matches else None


def extract_response_after_assistant(response):
    """
    Extract the part of the response that comes after the 'assistant' marker.

    Parameters:
    - response: The complete response from the model.

    Returns:
    - String: The extracted relevant part of the response.
    """
    # Split the response based on the 'assistant' marker
    parts = response.split('assistant', 1)
    # Return the part after 'assistant' or the entire response if 'assistant' is not found
    return parts[1].strip() if len(parts) > 1 else response.strip()


def evaluate_model_response(model_response, question_data, first_option=True):
    """
    Compare the model's response with the correct answer from the question data.

    Parameters:
    - model_response: The response string generated by the model.
    - question_data: Dictionary containing the question, options, and the correct answer.

    Returns:
    - 1 if the response is correct, otherwise the extracted model option.
    """
    correct_option = extract_option(question_data['answer'], first_option=first_option)  # Extract correct option
    relevant_response = extract_response_after_assistant(model_response)  # Get relevant part of response
    model_option = extract_option(relevant_response, first_option=first_option)  # Extract model's option

    return 1 if model_option == correct_option else model_option  # Return 1 if correct, else model's option


def format_answer(answer):
    # Remove punctuation and convert to lowercase
    answer_no_punctuation = answer.translate(str.maketrans('', '', string.punctuation))
    return answer_no_punctuation.lower()


def extract_answer(text):
    # Check for the presence of 'assistant'
    assistant_match = re.search(r'assistant\s*(.*)', text, re.IGNORECASE | re.DOTALL)
    if assistant_match:
        # If 'assistant' is found, get the text that follows it
        assistant_text = assistant_match.group(1).strip()

        # Find all occurrences of 'answer:' and capture the text after the last one
        answer_matches = re.findall(r'answer:\s*(.*)', assistant_text, re.IGNORECASE | re.DOTALL)

        # Return the phrase after the last 'answer:' found
        return answer_matches[-1].strip() if answer_matches else assistant_text

    # Return None if 'assistant' is not found
    return None